---
title: 'Code Examples'
description: 'Learn how to write and organize code in your Astrio applications'
---

## Code Organization

Astrio promotes clean, maintainable code through well-defined patterns and conventions.

### Component Structure

Follow these patterns when creating components:

```jsx
// components/UserCard.jsx
import { useState } from 'react';
import { Card, Avatar, Button } from '@astrio/ui';

export function UserCard({ user, onEdit, onDelete }) {
  const [isLoading, setIsLoading] = useState(false);

  const handleEdit = async () => {
    setIsLoading(true);
    try {
      await onEdit(user.id);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Card className="p-4">
      <div className="flex items-center space-x-4">
        <Avatar src={user.avatar} alt={user.name} />
        <div className="flex-1">
          <h3 className="font-semibold">{user.name}</h3>
          <p className="text-gray-600">{user.email}</p>
        </div>
        <div className="space-x-2">
          <Button 
            onClick={handleEdit} 
            loading={isLoading}
            variant="outline"
          >
            Edit
          </Button>
          <Button 
            onClick={() => onDelete(user.id)}
            variant="destructive"
          >
            Delete
          </Button>
        </div>
      </div>
    </Card>
  );
}
```

### API Routes

Create robust API endpoints with proper error handling:

```javascript
// pages/api/users/[id].js
import { db } from '@astrio/database';
import { auth } from '@astrio/auth';

export default async function handler(req, res) {
  // Authentication check
  const user = await auth.getUser(req);
  if (!user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { id } = req.query;

  try {
    switch (req.method) {
      case 'GET':
        return await getUser(id, res);
      case 'PUT':
        return await updateUser(id, req.body, res);
      case 'DELETE':
        return await deleteUser(id, res);
      default:
        res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
        return res.status(405).json({ error: 'Method not allowed' });
    }
  } catch (error) {
    console.error('API Error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

async function getUser(id, res) {
  const user = await db.user.findUnique({
    where: { id: parseInt(id) },
    select: { id: true, name: true, email: true, createdAt: true }
  });

  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  return res.status(200).json(user);
}

async function updateUser(id, data, res) {
  const { name, email } = data;

  // Validation
  if (!name || !email) {
    return res.status(400).json({ error: 'Name and email are required' });
  }

  const user = await db.user.update({
    where: { id: parseInt(id) },
    data: { name, email },
  });

  return res.status(200).json(user);
}

async function deleteUser(id, res) {
  await db.user.delete({
    where: { id: parseInt(id) }
  });

  return res.status(204).end();
}
```

### Database Operations

Use Astrio's database utilities for clean data access:

```javascript
// utils/database.js
import { db } from '@astrio/database';

export class UserService {
  static async create(userData) {
    return await db.user.create({
      data: {
        ...userData,
        createdAt: new Date(),
      },
    });
  }

  static async findById(id) {
    return await db.user.findUnique({
      where: { id },
      include: {
        posts: true,
        profile: true,
      },
    });
  }

  static async update(id, data) {
    return await db.user.update({
      where: { id },
      data: {
        ...data,
        updatedAt: new Date(),
      },
    });
  }

  static async delete(id) {
    // Soft delete
    return await db.user.update({
      where: { id },
      data: {
        deletedAt: new Date(),
        isActive: false,
      },
    });
  }

  static async list(options = {}) {
    const { page = 1, limit = 10, search } = options;
    
    const where = {
      isActive: true,
      ...(search && {
        OR: [
          { name: { contains: search, mode: 'insensitive' } },
          { email: { contains: search, mode: 'insensitive' } },
        ],
      }),
    };

    const [users, total] = await Promise.all([
      db.user.findMany({
        where,
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { createdAt: 'desc' },
      }),
      db.user.count({ where }),
    ]);

    return {
      users,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
      },
    };
  }
}
```

### Form Handling

Create forms with validation and error handling:

```jsx
// components/UserForm.jsx
import { useState } from 'react';
import { useForm } from '@astrio/forms';
import { Input, Button, Alert } from '@astrio/ui';

export function UserForm({ user, onSubmit }) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState(null);

  const { register, handleSubmit, formState: { errors } } = useForm({
    defaultValues: {
      name: user?.name || '',
      email: user?.email || '',
      role: user?.role || 'user',
    },
    validation: {
      name: {
        required: 'Name is required',
        minLength: { value: 2, message: 'Name must be at least 2 characters' },
      },
      email: {
        required: 'Email is required',
        pattern: {
          value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
          message: 'Invalid email address',
        },
      },
    },
  });

  const onSubmitForm = async (data) => {
    setIsSubmitting(true);
    setError(null);

    try {
      await onSubmit(data);
    } catch (err) {
      setError(err.message || 'An error occurred');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmitForm)} className="space-y-4">
      {error && (
        <Alert variant="destructive">
          {error}
        </Alert>
      )}

      <div>
        <Input
          label="Name"
          {...register('name')}
          error={errors.name?.message}
          placeholder="Enter your name"
        />
      </div>

      <div>
        <Input
          label="Email"
          type="email"
          {...register('email')}
          error={errors.email?.message}
          placeholder="Enter your email"
        />
      </div>

      <div>
        <Select
          label="Role"
          {...register('role')}
          error={errors.role?.message}
        >
          <option value="user">User</option>
          <option value="admin">Admin</option>
          <option value="moderator">Moderator</option>
        </Select>
      </div>

      <Button
        type="submit"
        loading={isSubmitting}
        disabled={isSubmitting}
        className="w-full"
      >
        {user ? 'Update User' : 'Create User'}
      </Button>
    </form>
  );
}
```

### Custom Hooks

Create reusable logic with custom hooks:

```javascript
// hooks/useApi.js
import { useState, useEffect } from 'react';

export function useApi(endpoint, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const { dependencies = [], method = 'GET' } = options;

  useEffect(() => {
    let isCancelled = false;

    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);

        const response = await fetch(endpoint, {
          method,
          headers: {
            'Content-Type': 'application/json',
          },
          ...options,
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();

        if (!isCancelled) {
          setData(result);
        }
      } catch (err) {
        if (!isCancelled) {
          setError(err.message);
        }
      } finally {
        if (!isCancelled) {
          setLoading(false);
        }
      }
    };

    fetchData();

    return () => {
      isCancelled = true;
    };
  }, [endpoint, ...dependencies]);

  const refetch = () => {
    setLoading(true);
    setError(null);
    // Trigger useEffect by updating a dependency
  };

  return { data, loading, error, refetch };
}

// Usage example
function UserList() {
  const { data: users, loading, error, refetch } = useApi('/api/users');

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <Button onClick={refetch}>Refresh</Button>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}
```

### Environment Configuration

Manage environment-specific settings:

```javascript
// config/index.js
const config = {
  development: {
    apiUrl: 'http://localhost:3000/api',
    dbUrl: 'postgresql://localhost:5432/astrio_dev',
    logLevel: 'debug',
  },
  production: {
    apiUrl: 'https://api.astrio.dev',
    dbUrl: process.env.DATABASE_URL,
    logLevel: 'error',
  },
  test: {
    apiUrl: 'http://localhost:3001/api',
    dbUrl: 'postgresql://localhost:5432/astrio_test',
    logLevel: 'silent',
  },
};

const env = process.env.NODE_ENV || 'development';

export default config[env];
```

## Best Practices

<AccordionGroup>
  <Accordion title="Error Handling">
    - Always handle errors gracefully
    - Provide meaningful error messages
    - Log errors for debugging
    - Use try-catch blocks appropriately
    - Implement global error boundaries
  </Accordion>

  <Accordion title="Performance">
    - Use React.memo for expensive components
    - Implement proper loading states
    - Optimize database queries
    - Use caching where appropriate
    - Lazy load heavy components
  </Accordion>

  <Accordion title="Security">
    - Validate all user inputs
    - Sanitize data before database operations
    - Use HTTPS in production
    - Implement proper authentication
    - Follow OWASP security guidelines
  </Accordion>
</AccordionGroup> 